#!/usr/bin/env python
# -*- coding: UTF-8 -*-
import csv
import inspect
import math
from matplotlib.backend_bases import FigureCanvasBase
from matplotlib.figure import Figure, SubplotParams
from matplotlib.ticker import FuncFormatter
import matplotlib.cm
import numpy
import os
import os.path
import re
import stat
import string
import subprocess
import sys
import time
import yaml

from optparse import OptionParser, OptionGroup
from distutils import spawn

try:
    import platform
    import ctypes
    libcver = platform.libc_ver()
    if libcver[0] == 'libc':
        libc = ctypes.CDLL("libc.so.%s" % libcver[1])
    elif libcver[0] == 'glibc' and libcver[1].startswith("2."):
        libc = ctypes.CDLL("libc.so.6")
    else:
        libc = None
    if libc:
        sync = libc.sync
    else:
        sync = lambda : None
except:
    sync = lambda : None

# A empty exception class
# used to catch managed exception and errors
class FioException(Exception):
    pass
 
def check_dev(blockdevice):
    try:
        blockdev = os.stat(blockdevice)
        return stat.S_ISBLK(blockdev.st_mode)
    except:
        return False

class FioStat(object):

    label      = property(lambda x: x._label, None, None, "label")
    values     = property(lambda x: x._values, None, None, "all fio values")
    version    = property(lambda x: x._values[0], None, None, "data version")
    read_bw    = property(lambda x: x._values[6], None, None, "read bandwith")
    write_bw   = property(lambda x: x._values[47], None, None, "write bandwith")
    read_iops  = property(lambda x: x._values[7], None, None, "read iop/s")
    write_iops = property(lambda x: x._values[48], None, None, "write iop/s")
    # join Âµs to 2ms, skip 75ms and 750ms
    latencies  = property(lambda x: [reduce(lambda x,y: x+y, x._values[99:110])] + x._values[110:117] + [reduce(lambda x,y: x+y, x._values[117:119])]+ x._values[119:120], None, None, "IO latencies")

    def __init__(self, label, values):
        if len(values) < 1:
            raise FioException("invalid fio stat line for run label '%s': %s" % (label, values))
        self._values = values
        self._label = label
        if self.version == 3 and len(values) < 120:
            raise FioException("invalid fio stat line for run label '%s': %s" % (label, values))

# A class used as a container for command
# To add a new command, just add a staticmethod to this class
class Commands(object):

    @staticmethod
    def modify_cciss(object, command, hpacucli, slot=None, ld=None):
        sync()
        identity = []
        identity.extend(["ctrl", "slot=%s" % slot])
        if object == "ld":
            identity.extend(["ld", "%s" % ld])
        cciss_args = [ check_executable(hpacucli)]
        cciss_args.extend(identity)
        cciss_args.append("modify")
        cciss_args.extend(command.split(" "))
        hpacuclip = subprocess.Popen(cciss_args, stdin=None)
        return hpacuclip.wait()
        
    @staticmethod
    def get_cciss_info(slot, ld, hpacucli):
        sync()
        check_ld = subprocess.Popen([hpacucli, "ctrl", "slot=%s" % slot, "ld", "%s" % ld, "show"], stdin=None, stdout=subprocess.PIPE)
        output = check_ld.communicate()[0]
        if check_ld.wait() != 0:
            return {}
        values = {}
        for l in re.split("\n", output):
    	    entry = re.split(":", l)
            if len(entry) == 2:
                values[entry[0].strip()] = entry[1].strip()
        return values

    @staticmethod
    def wait_cciss_ld(slot, ld, hpacucli):
        while True:
            ld_info = Commands.get_cciss_info(slot=slot, ld=ld, hpacucli=hpacucli)
            if not "Parity Initialization Status" in ld_info:
                return
            if ld_info["Parity Initialization Status"] == "Initialization Completed":
                return
            if "Parity Initialization Progress" in ld_info:
                print ld_info["Parity Initialization in Progress"]
            time.sleep(30)

    @staticmethod
    def do_cciss_ld(slot, ld, raid, hpacucli, stripsize=None):
        ld_info =  Commands.get_cciss_info(slot=slot, ld=ld, hpacucli=hpacucli)
        if 'Disk Name' in ld_info:
            blockdevice = ld_info['Disk Name']
            if check_dev(blockdevice):
                for mount_info in ld_info['Mount Points'].split(','):
                    if mount_info.strip() == 'None':
                        continue
                    mount_point = mount_info.strip().split(' ')[0]
                    Commands.smart_unmount(path=mount_point)
                hpacuclip = subprocess.Popen([hpacucli, "ctrl", "slot=%s" % slot, "ld", "%s" % ld, "delete", "forced"], stdin=None)
                status = hpacuclip.wait()
                if status != 0:
                    raise FioException("hpacucli failed with status %s", status)
            sync()
        hpacuclip = subprocess.Popen([hpacucli, "ctrl", "slot=%s" % slot, "create", "type=ld", "raid=%s" % raid, "drives=all", "ss=%s" % stripsize], stdin=None)
        return hpacuclip.wait()

    @staticmethod
    def smart_unmount(path=None, part=None, blockdevice=None):
        if blockdevice:
            if not check_dev(blockdevice):
                return True
            # substitution needed because of cciss/cXdX with HP's Smart Arrays
            old_path = os.getcwdu()
            os.chdir('/sys/block/%s' % blockdevice.replace('/dev/','').replace('/', '!') )
            for d in filter( lambda x: stat.S_ISDIR(os.stat(x).st_mode ) and os.path.exists("%s/dev" % x),
                             os.listdir('.')):
                if Commands.smart_unmount(part="/dev/%s" % d.replace('!', '/')) != 0:
                    os.chdir(old_path)
                    return False
            os.chdir(old_path)
            return 0
        if part:
            proc_mount = open('/proc/mounts', 'r')
            for l in proc_mount.readlines():
                mounted = l.split(" ")
                if mounted[0] == part:
                    path = mounted[1]
                    break
        if not path or not os.path.isdir('path'):
            return
        old_path = os.getcwdu()
        os.chdir(path)
        benchdir = os.stat(".")
        updir = os.stat("..")
        os.chdir(old_path)
        if benchdir.st_dev != updir.st_dev:
            return subprocess.Popen(["umount", path]).wait()

    @staticmethod
    def do_part(blockdevice, stripsize=0, stripcount=0):
        Commands.smart_unmount(blockdevice=blockdevice)
        sfdisk_args = ["sfdisk", "-L" ]
        if stripsize != 0 and stripcount != 0:
            while stripsize * 2 > 63:
                stripsize /= 2
                stripcount *= 2
            sfdisk_args.extend(["-uC", "-H", "%s" % stripcount , "-S", "%s" % (stripsize * 2)])
        sfdisk_args.append(blockdevice)
        sfdisk = subprocess.Popen(sfdisk_args, stdin=subprocess.PIPE)
        sfdisk.communicate(input="1,,,\n")
        if sfdisk.wait() == 0:
            sync()
            return subprocess.Popen(["blockdev", "--flushbufs", blockdevice]).wait()
        else:
            return False

    @staticmethod
    def do_fs_xfs(part, logdev=None, stripsize=0, stripcount=0):
        Commands.smart_unmount(part=part)
        if not check_dev(part):
            return False
        if logdev and not check_dev(logdev):
            return False
        mkfs_args = ["mkfs.xfs", "-f", "-L", "bench"]
        if logdev:
            mkfs_args.extend(["-l", "logdev=%s" % logdev, "-l", "size=2136997888" ])
        if stripsize !=0 and stripcount != 0:
            mkfs_args.extend(["-d", "su=%s" %(stripsize * 1024), "-d", "sw=%s" % stripcount])
        mkfs_args.append(part)
        return subprocess.Popen(mkfs_args).wait()

    @staticmethod
    def do_mount(part, mount_point, fs_type, options = []):
        Commands.smart_unmount(path=mount_point)
        sync()
        if not os.path.isdir(mount_point):
            if not os.path.exists(mount_point):
                os.mkdir(mount_point)
            else:
                raise FioException("mount point %s is not a directory" % mount_point)
        mount_args = ["mount", "-t", fs_type]
        if len(options) > 0:
            mount_args.append("-o")
            mount_args.append(",".join(options))
        mount_args.append(part)
        mount_args.append(mount_point)
        return subprocess.Popen(mount_args).wait()

    @staticmethod
    def do_mount_xfs(part, mount_point, logdev=None, noatime=True, inode64=True):
        options = []
        if noatime:
            options.append("noatime")
        if inode64:
            options.append("inode64")
        if logdev:
            options.append("logdev=%s" % logdev)
        return Commands.do_mount(part, mount_point, 'xfs', options)
    
    @staticmethod
    def sched_tune(blockdevice, scheduler=None, tunes = {}):
        if scheduler:
            scheduler_file = '/sys/block/%s/queue/scheduler' % blockdevice.replace('/dev/','').replace('/', '!')
            stat_info = os.stat(scheduler_file)
            if not stat.S_ISREG(stat_info.st_mode):
                raise FioException("invalid scheduler controler: %s", scheduler_file)
            with open(scheduler_file, "w") as f:
                f.write(scheduler)
        if len(tunes) > 0:
            scheduler_dir = '/sys/block/%s/queue/iosched' % blockdevice.replace('/dev/','').replace('/', '!')
            stat_info = os.stat(scheduler_dir)
            if not stat.S_ISDIR(stat_info.st_mode):
                raise FioException("invalid scheduler directory controler: %s", scheduler_dir)
            for (tune, value) in tunes.items():
                tune_file = '%s/%s' % (scheduler_dir, tune )
                stat_info = os.stat(tune_file)
                if not stat.S_ISREG(stat_info.st_mode):
                    raise FioException("invalid scheduler tuner file: %s", tune_file)
                with open(tune_file, "w") as f:                    
                    f.write("%s" % value)

    @staticmethod
    def do_fio(label, fio_script, fio_dir, fio = "fio", opts = None, count = 1, variables = {}):
        check_executable(fio)

        # if a variable is a dict, use the label as a key to the real value
        variables_clean ={}
        for (key, value)  in variables.items():
            if value.__class__ == {}.__class__:
                variables_clean[key] = value[label]
            else:
                variables_clean[key] = value

        flush_perms = True
        for i in range(count):
            sync()
            if flush_perms:
                try:
                    drop_caches = open('/proc/sys/vm/drop_caches', 'w')
                    drop_caches.write('3')
                    drop_caches.close
                except IOError:
                    flush_perms = False
                    print "insufficient permissions to flush caches, results might be not reproductible"
            try:
                if not stat.S_ISDIR(os.stat(fio_dir).st_mode):
                    raise FioException("not fio run dir: %s" % fio_dir)
            except OSError as e:
                if e.errno == 2 and e.filename == fio_dir:
                    os.mkdir(fio_dir)
                else:
                    raise FioException("do_fio failed: %s", e)
            (script_r, script_w) = os.pipe()
            fio_args = [fio, "/dev/fd/%d" % script_r, "--minimal"]
            if opts:
                fio_args.extend(opts)
            fio_process = subprocess.Popen(fio_args, stdout=subprocess.PIPE, preexec_fn=lambda: os.close(script_w))
            os.close(script_r)
        
            # Parse the fio script as a template
            with open(fio_script, "r") as fio_script_file:
                for line in fio_script_file:
                    try:
                        os.write(script_w, string.Template(line).substitute(variables_clean))
                    except KeyError as e:
                        raise FioException("Unknown variable: %s", e)
            os.close(script_w)
        
            fio_stdout = fio_process.communicate()[0]
            status = fio_process.wait()
            if status != 0:
                raise FioException("fio run failed: %s\n%s" % (status, fio_stdout))
            # The fio run output is cleaned to be parsable by a csv.reader
            # don't parse error line, display them
            for found in re.compile(r'^(\d+;fio-.*)?(.*)$', re.MULTILINE).findall(fio_stdout):
                if len(found[0]) > 0:
                    fio_stdout = found[0]
                    break
                elif len(found[1]) > 0:
                    print found[1]
            fio_stdout = fio_stdout.replace("%", "")

            # a while because this regex will not manage two consecutive string
            quote_string = re.compile(r'(^|;)([^;"\n]*[A-Za-z=][^;"\n]*)(;|$)')
            while True:
                # wrapping all textual values with a ".."
                (fio_stdout, count) = quote_string.subn(r'\1"\2"\3', fio_stdout)
                if count == 0:
                    break
            try:
                cvs_line = csv.reader(re.split("\n", fio_stdout), delimiter=';', quoting=csv.QUOTE_NONNUMERIC).next()
                yield (label, cvs_line)
            except ValueError as e:
                raise FioException("can't parse fio run output: %s\n%s" % (e, fio_stdout))
            
    @staticmethod
    def clean(fio_dir):
        try:
            for root, subFolders, files in os.walk(fio_dir, topdown=False):
                for folder in subFolders:
                    os.rmdir(os.path.join(root,folder))
                for onefile in files:
                    os.remove(os.path.join(root,onefile))
        except OSError as e:
            raise FioException("clean %s failed: %s" % (fio_dir, e))

def run_script(script):
    fio_values = []
    for (f, kwargs)  in script:
        print "step %s(%s)" % (f.__name__, kwargs)
        try:
            execute = f(**kwargs)
        except TypeError as e:
            raise FioException("%s failed: '%s', command parameters: %s" % (f.__name__, e, kwargs))
        if type(execute) == type(1) and execute != 0:
            raise FioException("%s failed: %s" % (f.__name__, execute))
        elif execute is False:
            raise FioException("%s failed: %s" % (f.__name__, execute))
        elif execute.__class__.__name__ == 'generator':
            for yielded in execute:
                if type(yielded) == type(()) and len(yielded) == 2:
                    fio_values.append(FioStat(yielded[0], yielded[1]))

    return fio_values

def run_yaml(script_yaml,skip):
    script = []
    for cmd in script_yaml['run'][skip:]:
        # if the command is a plain string,
        # it's a command without arguments
        if type(cmd) == type(""):
            cmd = {cmd: None}
        cmd_name = cmd.keys()[0]
        cmd_args = cmd[cmd_name]
        if cmd_args == None:
            cmd_args = {}
        if cmd_name not in solver:
            print "unknown %s" % cmd_name
        cmd_func = solver[cmd_name]
        kwargs = {}
        # Enumerate all argument in the function, and check from where
        # to find the value
        for arg_name in inspect.getargspec(cmd_func).args:
            if arg_name in cmd_args:
                kwargs[arg_name] = cmd_args[arg_name]
                del cmd_args[arg_name]
            elif arg_name == 'variables':
                kwargs[arg_name] = script_yaml['variables']
            elif arg_name in script_yaml['defaults']:
                kwargs[arg_name] = script_yaml['defaults'][arg_name]
        # not all arguments from the yaml file used, something is wrong
        if len(cmd_args) > 0:
            raise FioException("Unused argument %s for %s" % (cmd_args.keys(), cmd_name))
        script.append((cmd_func, kwargs))

    return run_script(script)

def plot(fio_values, mode="bw", filename=None):
    column_labels = [ "<=2", "4", "10", "20", "50", "100", "250", "500", "1000", "2000", ">=2000" ]
    
    row_labels = []
    ms_values = []
    bw_values_read = []
    bw_values_write = []
    iops_values_read = []
    iops_values_write = []
    for row in fio_values:
        row_labels.append(row.label)
        bw_values_read.append(row.read_bw)
        iops_values_read.append(row.read_iops)
        bw_values_write.append(row.write_bw)
        iops_values_write.append(row.write_iops)
        ms_values.append(row.latencies)

    x = numpy.arange(len(ms_values))
    y = numpy.arange(len(ms_values[0]))
    X, Y = numpy.meshgrid(x, y)

    waitarray = numpy.array(ms_values).transpose()
    maxwait = numpy.amax(ms_values)
    normalized = waitarray/maxwait * 1000

    fig = Figure(subplotpars=SubplotParams(right=0.85, left=0.07))
    ax1 = fig.add_subplot(1, 1, 1)

    ax1.set_xticks(numpy.arange(len(row_labels)), minor=False)
    ax1.set_xticklabels(row_labels, minor=False)

    ax2 = ax1.twinx()

    # draw the latencies circles
    ax1.scatter(X.ravel(), Y.ravel(), c=Y, s=normalized.ravel(), alpha=0.5, cmap="jet")

    ax1.set_xlim(-0.5, len(row_labels) - 0.5)

    ax1.set_ylim(bottom=-1)
    ax1.set_yticks(range(len(column_labels)))
    ax1.set_yticklabels(column_labels, minor=False)

    # Draw the bw or io/s line
    if mode == "bw":
        to_plot_read = bw_values_read
        to_plot_write = bw_values_write
        ylabel = 'bandwidth'
        radix = 1024
        base = 8
    else:
        to_plot_read = iops_values_read
        to_plot_write = iops_values_write
        ylabel = 'io/s'
        radix = 1000
        base = 10

    # pop start from the end
    magnitude_symbols = ["M", "G", "T"]
    magnitude_symbols.reverse()

    max_plot = max(numpy.amax(to_plot_read), numpy.amax(to_plot_write))
    if max_plot != 0:
        max_plot = math.pow(base, math.ceil(math.log(max_plot, base)))
    
    factor = 1
    symbol = "k"
    max_plot_temp = max_plot
    while max_plot_temp > radix:
        max_plot_temp /= radix
        factor *= radix
        symbol = magnitude_symbols.pop()
    
    if radix == 1024 and symbol:
        symbol += 'i'

    ax2.set_ylabel(ylabel, color='b')
    for tl in ax2.get_yticklabels():
        tl.set_color('b')
    formatter = FuncFormatter(lambda x,y: '%1.1f %s' % (x / factor, symbol))
    ax2.yaxis.set_major_formatter(formatter)
    ax2.plot(x, to_plot_read, 'b.-')
    ax2.plot(x, to_plot_write, 'g+-')

    plot_array = numpy.array(to_plot_read + to_plot_write)

    y_max = plot_array.max()
    y_max_new = math.pow(2 , math.ceil(math.log(y_max, 2)))
    ax2.set_ylim(0, y_max_new * 1.2)
    yticks = map(lambda x: (1.0 * x/base) * y_max_new, range(base))
    ax2.set_yticks(yticks, minor=False)

    if filename:
        canvas = FigureCanvasBase(fig)
        canvas.print_figure(filename)
    else:
        # import only when needed, it uses X11
        import matplotlib.pyplot
        matplotlib.pyplot.show(fig)


def save_csv(fio_values, filename):
    with open(filename, 'wb') as csvfile:
        cvsoutput = csv.writer(csvfile, delimiter=',',
                                quotechar='"', quoting=csv.QUOTE_NONNUMERIC)
        for row in fio_values:
            cvsoutput.writerow([row.label] + row.values)

def read_csv(filename, values=[]):
    with open(filename, 'rb') as csvfile:
        csv_input = csv.reader(csvfile, delimiter=',', quotechar='"', quoting=csv.QUOTE_NONNUMERIC)
        for row in csv_input:
            if row:
                values.append(FioStat(row[0], row[1:]))
    return values

def check_executable(filename):
    if filename is None:
        raise FioException("no command given")
    filename_path = spawn.find_executable(filename)
    if filename_path is not None:
        try:
            if not os.access(filename_path,  os.X_OK):
                raise FioException("no executable command '%s'" % filename_path)
        except OSError as e:
            raise FioException("no valid command path '%s': '%s'" % (filename_path, e))
    else:
        raise FioException("command '%s' not found in path" % filename)
    return filename_path

def read_yaml(filename, defaults, variables, skip):
    try:
        yaml_file = open(filename)
        script_yaml = yaml.safe_load(yaml_file)
        yaml_file.close()
    except yaml.parser.ParserError as e:
        print "invalid file %s:" % filename
        print e
        return
    if not 'defaults' in script_yaml:
        script_yaml['defaults'] = {}
    for (key,value) in defaults.items():
        if not key in script_yaml['defaults']:
        script_yaml['defaults'][key] = value
        
    if not 'variables' in script_yaml:
        script_yaml['variables'] = {}        
    for (key,value) in variables.items():
        script_yaml['variables'][key] = value

    # check the executable path
    script_yaml['defaults']['fio'] = check_executable(script_yaml['defaults']['fio'])
    script_yaml['defaults']['hpacucli'] = check_executable(script_yaml['defaults']['hpacucli'])

    #check if fio
    fio_cmd = script_yaml['defaults'].get('fio')
    if fio_cmd is not None and not check_executable(fio_cmd):
        return

    fio_values = run_yaml(script_yaml, skip)
    if len(fio_values) > 0:
        if('csv' in script_yaml):
            save_csv(fio_values, **script_yaml['csv'])
        plot(fio_values, **script_yaml['plot'])

def main():

    parser = OptionParser(usage="\n%prog [options] yaml_script+\n%prog -c [options] csv_values+")

    yaml_group = OptionGroup(parser, "Yaml script execution")
    yaml_group.add_option("-V", "--variable", dest="variables", action="append", default = [])
    yaml_group.add_option("-D", "--default", dest="defaults", action="append", default = [])
    yaml_group.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False)
    yaml_group.add_option("-S", "--skip", action="store", dest="skip", default=0, type=type(0))
    parser.add_option_group(yaml_group)

    csv_group = OptionGroup(parser, "Plot from a list of csv")
    csv_group.add_option("-c", "--csv", action="store_true", dest="csv_input", default=False)
    csv_group.add_option("-m", "--mode", action="store", dest="graph_mode", default="iops", type="choice", choices=("bw", "iops") )
    csv_group.add_option("-p", "--png", action="store", dest="png_output", default=None, type=type(""))
    parser.add_option_group(csv_group)

    (options, args) = parser.parse_args()

    defaults = { 'fio': 'fio', 'hpacucli': 'hpacucli'}
    for default in options.defaults:
        (key, value) = default.split("=")
        if key == 'count':
            value = int(value)
        defaults[key] = value
    
    variables = {}
    for default in options.variables:
        (key, value) = default.split("=")
        variables[key] = value

    if len(args) == 0:
        parser.print_usage()
        exit(1)

    if not options.csv_input:
    for file_use in args:
           try:
               read_yaml(file_use, defaults, variables, options.skip)
           except FioException as e:
               print e
               break
    else:
        values = []
        for file_use in args:
            values = read_csv(file_use)

        plot(values, mode=options.graph_mode, filename=options.png_output)


solver = {}
for (name, function) in inspect.getmembers(Commands, predicate=inspect.isfunction):
    solver[name] = function

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(1)
